# Memory & Garbage Collection

## 内存管理

- 内存：由可读写单元组成，表示一片可操作空间
- 管理：人为地去操作一片空间的申请、使用和释放
- 内存管理：开发者主动申请内存空间、使用、释放
- 管理流程：申请->使用->释放

### JS 中的内存管理

```js
// 申请空间
const obj = {};

// 使用空间
obj.k = "k";

// 释放空间
obj = null;
```

## JS 中的垃圾回收

- JS 中的内存管理是自动的
- 对象不再被引用时=>垃圾
- 对象不能从根上（web dev 中 window）访问时=>垃圾

### 概念：可达 + 引用

- 可达：可以从根出发访问到（引用、作用域链）
- 根：全局变量对象 window
- 引用：对象被某一个变量的指针指向着的情况

### GC 和垃圾是什么

- GC：垃圾回收机制（Garbage Collection）的简写
- 作用：找到内存中的垃圾，释放、回收空间
- 垃圾的定义：不再需要或不能访问到的对象
- 垃圾回收器：它完成具体的垃圾回收工作（查找、释放、回收内存空间）

## GC 算法

- 算法：工作时查找和回收所遵循的规则，以下是一些算法名称：
  - 引用计数
  - 标记清除
  - 标记整理
  - 分代回收

## GC 引用计数算法

- 核心思想：设置引用数，判断当前引用数是否为 0
- 引用计数器：
  - 会在引用关系发生改变时修改引用计数
  - 引用数字为 0 时立即回收

```js
function fn() {
  num1 = 1;
  num2 = 2;
}
fn();
// 执行函数后，num1和num2成了全局变量，占用内存
// 全局变量引用着1和2，所以GC不会回收
console.log(num1); // 1
// 这时 num1 并没有被回收
```

```js
function fn() {
  const num1 = 1;
  const num2 = 2;
}
fn();
// const和let定义时确定了作用域
// 在使用过后，引用计数为0，GC立即回收
console.log(num1); // num1 is not defined
```

### 引用计数算法 pros&cons

- pro: 发现垃圾时立即回收
- pro: 最大限度减少程序暂停：内存满后程序会暂停，引用计数算法会在内存将满时找到并清除垃圾，释放内存，故减少程序暂停
- con: 时间开销较其他算法更大：因为要时刻监控数值修改
- con: 对于函数内部的循环引用无法进行垃圾回收

## GC 标记清除算法

- 核心思想：标记和清除 2 个阶段

### 实现原理

- 阶段 1：遍历所有对象，找标记活动对象（可达对象）
- 阶段 2：遍历所有对象，清除没有标记的对象，抹掉阶段 1 中的标记，回收相应的空间

### 优缺点

- pro：可回收循环引用的对象（如：函数内部局部作用域中的循环引用）
- con：回收的内存地址不连续，回收后的内存碎片化，不匹配的数据无法使用
- con：不会立即回收垃圾对象

## GC 标记整理算法

- 标记清除算法的增强版

### 实现原理

- 阶段 1：和标记清除算法一样，遍历所有对象，找标记活动对象（可达对象）
- 阶段 2：回收前，先执行内存整理（移动对象位置） => 回收后内存地址连续，最大化利用剩余内存空间

### 优缺点

- pro：可回收循环引用的对象
- pro：减少碎片化空间
- con：不会立即回收垃圾对象

## V8 引擎

- V8 是一款主流的 JS 执行引擎
- V8 采用即时编译
- V8 内存限制（32 位系统 800MB；64 位系统 1.5GB）：
  - 网页应用足够使用
  - 垃圾回收机制：1.5G 时（增量标记）回收耗时 50ms，（非增量标记）耗时 1s

### V8 垃圾回收策略

- 分代回收算法
  - 内存 1 分为 2：新生代、老生代
  - 针对不同对象采用不同算法
- 空间复制
- 标记清除
- 标记整理
- 标记增量

### V8 新生代回收

- 新生代对象：生命周期相对较短的对象
- 新生代空间：64 位系统 32M，32 位系统 16M
- 新生代空间分割：分为 2 个大小相等的空间（from 和 to）
- 回收过程：标记清除、标记整理、置换
  - from：存放活动对象，所有的对象声明都会在这里
  - 触发 GC 机制后：
  - 在 from 空间中进行标记，找到活动对象
  - 在 from 空间中进行整理，防止内存地址碎片化
  - 从 from 空间中拷贝整理过后的活动对象至 to 空间中，此时可能发生晋升操作，即：将新生代对象移动至老生代，晋升标准：
    - 1 整轮 GC 回收过后还存货的新生代对象
    - to 空间使用率超过 25%，所有的 to 空间中的对象都会被复制进老生代空间
  - 释放 from 空间
  - 2 个空间进行交换，from 变成了 to，to 变成了 from，完成回收

### V8 老生代回收

- 老生代对象：生命周期相对较长的对象（如：闭包的对象等）
- 老生代空间：64 位系统 1.4GB，32 位操作系统 700MB
- 回收过程：
  - 标记清除算法：主要采用这种算法
  - 标记整理算法：当从新生代晋升的数据过大，老生代空间不足时使用
  - 增量标记算法：效率优化

### 标记增量

- 增量标记算法的使用场景：在老年代中使用标记增量算法做 GC，因为老年代中存放的数据较多（老年代存储区最多有 1.4G），采用类似新生代中的复制算法耗时较长，可能造成卡顿程序暂停的情况

- 增量标记算法工作原理

  1. 触发 GC 机制
  2. 此时程序继续执行
  3. 遍历一层可达对象，并做标记
  4. 程序继续执行
  5. 标记二层可达对象，并做标记
  6. 程序继续执行
  7. 标记完成
  8. 程序继续执行
  9. 整理内存、释放内存、完成回收

## Performance 工具
