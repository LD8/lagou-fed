# 习题模块二： ES 新特性与 TypeScript、JS 性能优化

## 一、请说出下列最终的执行结果，并解释为什么

```js
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6]();
```

### 结果会是`10`

- 使用 var 声明的变量为全局变量，i

---

## 二、请说出下列最终的执行结果，并解释为什么

```js
var tmp = 123;

if (true) {
  console.log(tmp);
  let tmp;
}
```

### 结果是`Uncaught ReferenceError: Cannot access 'tmp' before initialization`

- let 是 block 级声明，它的引用只在此 block 中可达
- 一个 block 中用 let 声明 tmp 后，全局的 tmp 在此 block 中就无法被引用（不可达）
- let 声明的变量在其被声明之前无法被引用，不会像 var 声明的变量一样显示 undefined

---

## 三、结合 ES6 新语法，用最简单的方式找出数组中的最小值

```js
var arr = [12, 34, 32, 89, 4];
console.log(arr.sort((a, b) => a - b)[0]);
```

---

## 四、请详细说明 var，let，const 三种声明变量的方式之间的具体差别

- 变量 scope 差别：var 是全局的，let 和 const 是块级的
- 变量属性：var 和 let 都是可以在声明后发生改变（重新被赋值）的，const 则不行，但是 const 在声明普通对象时，对象中的键值对却可以在后续被重新赋值
- 。。。

---

## 五、请说出下列代码最终输出的结果，并解释为什么

```js
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a);
    });
  },
};
obj.fn();
```

### 结果是 20

- this 指向 obj
- 即便没有 setTimeout 的话输出结果也是 20，原因同上

---

## 六、简述 symbol 类型的用途

- 因为 symbol 是独一无二的，可以用于避免对象中的属性名称或其他情况下的变量名称不发生冲突
- 可以使用‘计算属性名’的方式创建对象的私有成员，外部无法访问
- 在对象内部设置`Symbol.toStringTag`属性可以设置对象的`toString`标签
- 其他开发便利：如：`Symbol.iterator`、`Symbol.hasInstance`等

---

## 七、说说什么是浅拷贝，什么是深拷贝

- 浅拷贝：拷贝变量指针，使新变量名指向被拷贝对象，在修改新对象时可能使旧对象的属性也发生改变
- 深拷贝：拷贝一份新的被拷贝对象到内存中，拷贝对象和被拷贝对象完全分离，修改新对象不会对旧对象造成任何影响

---

## 八、请简述 TypeScript 与 JavaScript 之间的关系

- TS 是 JS 的超集：`TS === JS + 类型系统 + ES6+新特性`
- TS 会最终被编译为 JS 在生产环境中运行
- JS 是弱类型的动态语言，对变量的类型基本不作限制，使用 TS 后，JS 在语法上不发生改变但由于 TS 的限制成为了强类型的静态语言
- 任何 JS 运行环境都支持 TS，兼容性强

---

## 九、请谈谈你所认为的 TypeScript 的优缺点

- #### 优点

  - 强类型，在开发时规避掉大部分的类型错误，使开发变得轻松
  - 小型项目可能看不出巨大的优势，但应用在大型项目中、开发周期长的项目时会使开发过程更平稳，bug 量减少，不会等到程序运行时才报错
  - 灵活的配置系统使 TS 适合应用在各种使用 JS 的项目中
  - 更多类型便利开发：如枚举类型、抽象类中定义抽象方法等，使开发更灵活、更便捷
  - 泛型使开发大型项目时节约更多资源（少写很多代码）

- #### 缺点

  - 学习成本高
  - 开发初期的投入较高

---

## 十、描述引用计数的工作原理和优缺点

- 工作原理：遍历 -> 判断 -> 清除

  1. 遍历所有对象：统计在根上可达的变量和数量
  2. 监控引用关系：在引用关系发生改变时触发 GC
  3. 判断和清除：发现有引用数量为 0 的变量时即刻清除
  4. 释放空间，完成回收

- 优缺点

  - 优点：因为发现引用为 0 时立即执行 GC，不会等到内存报表，降低程序卡顿、暂停的频率
  - 缺点：无法回收循环引用的变量，因为要时刻监控数值修改，所以时间开销较大

---

## 十一、描述标记整理算法的工作流程

- 工作原理：遍历 -> 标记 -> 整理 -> 清除

  1. 遍历所有对象：寻找可达对象
  2. 标记：发现可达对象时进行标记
  3. 清除：抹去没有标记的变量
  4. 整理内存：减少内存碎片化，最大化利用内存（比标记清除算法多出来的一步）
  5. 释放空间，完成回收

- 优缺点

  - 优点：可以发现循环引用的变量并进行清除，最大程度减少内存碎片化，提高内存使用率
  - 缺点：不会立即回收，可能造成程序的卡顿

---

## 十二、描述 V8 引擎中新生代存储区垃圾回收的流程

- 新生代存储区垃圾回收的流程

  新生代存储区一共 32MB/16MB(对用 64 位/32 位系统)，分为 from 和 to 两部分，空间大小相等，回收流程为：标记清除、标记整理、两区互换

  1. 在 from 区接收新的内容，存放活动对象（变量、函数等实例引用）
  2. 触发 GC 机制后（什么触发的 GC 机制呢？）遍历 from 区中的对象，找到活动对象并标记
  3. 清除没有标记的对象
  4. 对内存进行整理防止碎片化
  5. 复制 from 中的整理过后的被标记内容到 to 区中
  6. 释放 from 中的空间
  7. from 和 to 交换位置

---

## 十三、描述增量标记算法在何时使用及工作原理

- 增量标记算法工作原理

  1. 触发 GC 机制
  2. 此时程序继续执行
  3. 程序短暂暂停：遍历一层可达对象，并做标记
  4. 程序继续执行
  5. 程序短暂暂停：标记二层可达对象，并做标记
  6. 程序继续执行
  7. 程序短暂暂停：完成标记工作
  8. 程序继续执行
  9. 程序短暂暂停：整理内存、释放内存、完成回收

- 增量标记算法的使用场景：在老年代中使用标记增量算法做 GC，因为老年代中存放的数据较多（老年代存储区最多有1.4G），采用类似新生代中的复制算法耗时较长，可能造成卡顿程序暂停的情况
